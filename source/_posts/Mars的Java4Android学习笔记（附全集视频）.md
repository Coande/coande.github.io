title: Mars的Java4Android学习笔记（附全集视频）
tags:
  - Android
  - Java
  - Mars
  - 笔记
  - 面向对象
id: 73
categories:
  - 软件
date: 2015-01-29 20:22:48
---

　　花费了我不少的时间终于将Mars老师的Java4Android系列视频教程给看完了。刚开始看的时候我是没有做笔记的，但看到30集左右就觉得看不懂了，前面的知识也忘记得差不多了。我想我再也看不下去了，所以又重新从第13集开始看一遍。这才意识到做笔记的重要性。而这些笔记记录了视频中的重点内容和一些自己难以理解的内容，其中还包括自己思考问题的一些方法……<!--more-->

笔记开始----------&gt;
***
类的属性=类的成员变量
类的方法=类的成员函数
对象存在于堆内存中
对象的引用存在于桟内存中
成员变量和成员函数的使用方式：对象名（对象的引用）.成员变量(成员函数)
匿名对象是一次性对象，可以直接调用这个对象的方法
匿名对象例子：new Dog().jump()

一个类中 的函数名字可以相同 (但是参数列表是不可以相同的)，这种现象叫做函数的重载（overload）
生成对象时的类名加括号是构造函数，是特殊的函数，不是成员函数。例如：A(){}
构造函数的特征：没有返回值的类型；构造函数的名字必须和类名相同
编译器在编译时会检查是否有构造函数，若无则会自动加上无参数且方法体为空的构造函数
调用普通的函数都是用“对象.函数”；调用构造函数则是“new 构造函数”
构造函数的作用：调用构造函数的时候会生成这个类的对象；可以为成员变量赋初始值
若已有构造函数，编译器不会自动添加构造函数

使用本类中的成员变量时可以省略对象名（对象名为this）
this代表调用该函数的对象
某函数的参数列表中参数与成员变量相同时,若不用this则该函数中的变量代表的是参数列表当中的参数；若用this则该函数中的变量代表的是成员变量。
this+(参数)来调用本类当中的其它构造函数。调用的是哪个构造函数由括号中的参数个数和类型决定。
若在构造函数中使用this来调用其它构造函数，则这个this一定要是该构造函数的第一个语句。

静态变量和静态函数都是在前面加static
静态成员变量可以用类名来调用（可以不用对象名调用）；
所有对象使用的静态成员变量是同一份（无论使用对象来调用还是使用类名来调用都成立）。可以这样想象：静态变量不是对象层次的变量而是类层次的变量。
静态函数也是无须生成对象，可以直接用类名来调用
静态函数中不能引用非静态的成员变量
静态代码块使用方法：static{语句}
静态代码块在装载这个类的时候执行
静态函数当中不能使用this
静态代码块的主要作用是为静态成员变量赋值

面向对象的三个特点：继承、封装和多态
面向对象对象的世界中，继承就是一个类得到了另外一个类当中的成员变量和成员方法（函数）
java当中只支持单继承，不允许多继承（一个子类只能有一个父类，但一个父类可以有多个子类）
继承的关键字：extends（翻译为扩展）
使用方法，例如：class Student extends Person{}
子类当中可以加入自己特有的成员变量和成员函数
使用继承是为了减少重复代码

继承不能继承构造函数，只能继承成员变量和成员函数
在子类的构造函数当中，必须调用父类的构造函数（编译器会检查，若没手动加上则编译器会自动调用（加上）父类当中无参数的构造函数）
调用父类的构造函数方法：super(参数)。
使用super调用父类当中的构造函数时，super必须是该构造函数中的第一条语句。
调用父类当中的哪个构造函数由参数的个数和类型确定。
生成子类的对象时，必须要调用父类当中的构造函数（若用户不定义则编译器自动处理）

复写、覆盖、重写（override）
概念：1.在具有父子关系的两个类当中2.父类和子类各有一个函数，这两个函数的定义（返回值类型、函数名、和参数列表）完全相同
函数复写后，生成子类的对象时，调用的是子类的函数（指复写的函数）；生成父类的对象时，调用的是父类的函数（指被复写的函数）
可以使用“super.父类中的成员函数”（不需要是函数的中的第一句）来调用父类当中的成员函数，从而减少重复代码

非常重要！
对象的转型是面向对象多态性的一种体现
向上转型；将子类的 对象 （已赋值的引用）赋值给父类的 引用 （未赋值）
一个引用能够调用哪些成员（变量和函数），取决于这个引用的类型
一个引用调用的是哪一个成员（变量和函数），取决于这个引用所指向的对象
向下转型：将父类的对象赋值给子类的引用
向下转型的前提是向上转型（即需要先向上转型后才能进行向下转型）。不能直接生成父类对象赋值给子类引用。
向下转型时需要进行强制类型转换

在有重复代码的时候应该想办法使用继承、this、super等来减少重复代码

抽象程度：
抽象类&gt;类&gt;对象
只有函数的定义，没有函数体的函数被称为抽象函数。例如：abstract void fun();
函数的定义 由函数的返回值类型、函数名、参数列表组成
使用abstract定义的类被称之为抽象类
抽象类不能生成对象
如果一个类当中包含有抽象函数，那么这个类必须声明为抽象类
如果一个类当中没有抽象函数，那么这个类也可以被声明为抽象类(不让别人生成这个类的对象)
抽象类可以有构造函数。（可以在子类构造函数中被调用）
抽象类的作用是用作父类，被继承。继承后，可以对抽象类中的抽象函数进行复写。复写后可以生成子类的对象。

抽象类最简单的一个作用：如果一个类中的某一个函数我们无法确定，需要由子类来实现，那么我们应该对这个函数使用抽象函数，并将这个类定义为抽象类。
如果一段代码在语意上是有错误的，那么在语法上也应该是有错误的

包的关键字：package
为类打包的方法：package 包名
含有包的类编译例子：javac -d . Test.java(其中“-d”代表根据包名生成相应的文件夹；“.”代表当前目录)
打包后一个类的全名应该是”包名“+”.“+"类名"，例如 Coande.Test
包名所有的字母都要小写
包名一般情况下是你的域名段倒过来写，如域名为e12e.com,则包名应该是com.e12e

Java当中的访问权限：public公共权限 private私有权限 default包级别访问权限 protected受保护权限
在两个不同的包中，如果一个类需要访问另外一个类，被访问的类必须为public权限；成员变量和成员函数也是如此。
public权限的类名称必须要和源文件的名称相同
跨包访问类时，类的全名应该是”包名“+”.“+"类名"，而同包访问时可直接使用类名；
一般情况下private用来修饰成员变量和成员函数。private的作用是只允许在本类中使用成员变量（函数）。
public、private权限用法为直接在相应的地方前面加上public、private。成员变量和成员函数前面什么都不写即为default权限
包的导入关键字：import
类导入后，使用导入的类不再需要使用”包名“+”.“+"类名"。可以使用“*”的方法导入整个包

如果子类和父类不在同一个包当中，子类可以继承到父类当中的default权限的成员变量和成员函数，但是由于权限不够，无法使用
protected权限首先拥有和default一样的功能，但是该权限只能修饰成员变量和成员函数
不同包中，protected只允许子类对父类的成员变量或成员函数的访问
public &gt;protected &gt;default &gt;private
权限体现了面向对象的封装性

面向对象的合金地带（精髓）：接口
定义一个接口使用interface。如：interface USB{}
接口当中的方法都是抽象方法
接口当中的方法都是public权限（默认权限即为public）
实现是特殊的继承（可以得到接口当中的成员变量和成员方法）
实现接口使用implements关键字；
实现一个接口需要使用一个类来implements接口(类似于extends)
实现一个接口需要复写（override）接口当中的抽象方法
一个类可以实现多个接口。接口之间使用逗号隔开，例如：class Phone implements USB,WiFi{}
接口也支持向上转型。生成接口实现（implements）类的对象后可以向上转型为接口类型
一个接口可以继承（extends）另外的多个接口

工厂方法模式
例如：增减打印机时，不需要涉及到用户使用的类，我们只需要添加一个该打印机的类，和适当修改打印机工厂这个类（好处是：当有多个用户时，不需要对多个用户逐个进行修改）
函数当中可以使用return语句返回一个对象
一个类中生成另外一个类的引用的方法：类名 引用名=null;
在一个类中可以使用另外一个类的类名作为本类中的函数的类型
在一个类中使用令一个类中的函数的返回值时，使用方法是：类名.函数名

异常也是对象
异常：中断了正常指令流的事件
当程序出现异常的时候，Java虚拟机会生成一个异常对象
异常是在程序运行时产生的，跟编译没有关系（程序在语法上是没有问题的）
Exception异常 Error错误
Error为虚拟机在运行时产生的错误，一旦产生错误，虚拟机会直接关闭
程序员对Error没有无能为力，只能处理Exception
一旦程序产生Error，虚拟机直接退出，我们能做到的是尽可能减少Error的出现
异常分为两大类，一类为运行时异常RuntimeException(UncheckException），另一类为编译时异常(CheckException)
异常处理大概方法（此处对异常处理的方法是输出错误信息）：try{有可能出现异常的代码} catch(Exception e){e.printStackTrace();} finally{清理资源的代码}
（解析：catch后必须有括号，括号内必须有参数；可以省略finally;e代表一个对象，名称可以更改）
如果try里面出现异常就会跳到并执行catch；如果try里面不出现异常则不会执行catch里面的语句;而无论是否出异常，都会执行finally
CheckException必须将可能出现异常的代码进行处理才能通过编译

有些异常Java虚拟机无法判断，需要程序员对其进行判断，生成一个异常对象，然后对其抛出（throw）
例如；RuntimeException e = new Runtime("年龄不能为负数");throw e;
程序运行到throw抛出异常对象后将会终止运行
RuntimeException属于UnchecekException,Exception属于CheckException，Exception除了RuntimeException其它子类都为CheckException
如果一段代码中有可能会抛出一个Exception(CheckException)对象,这段代码必须进行捕捉(try...catch)或声明(throws)处理
对可能产生CheckException对象的代码进行声明的方法是在该函数定义后面加上：throws Exception(指可能产生的异常对象)
声明后的异常并不由可能产生异常的函数进行处理，而是由调用这个函数的地方进行处理（需要使用try...catch进行处理）
自定义异常（其它异常也可以）可以使用“e.printStackTrace();”或"System.out.print(e);"输出错误信息

I/O操作的目标：从数据源当中读取数据，以及将数据写入到数据目的地当中
数据源很多，不仅仅指文件，还有键盘、网络等等。
I/O流向：数据源--&gt;（输入）Java程序--&gt;（输出）输出目的地。
输入和输出是相对于Java程序来说的（数据的流向以Java程序为参照物）
输入和输出不是一下子完成的，所以叫做输入流和输出流
IO流的分类（三种）。第一种分法：输入流、输出流。第二种：字节流、字符流。第三种：节点流、处理流。
I/O流也是对象
I/O当中的核心类：InputStream 核心类的核心方法。InputStream:int read(byte []b,int off,int len) OutputStream:void write(byte b,int off,int len)
一般情况下偏移量为0，读取的长度为数组的长度（数组名,length）
InputStream的read方法的返回值为读取到数据的长度（可用于写数据时的长度）
偏移量为n,则从第n+1个单位进行操作
InputStream和OutputStream是所有的字节流的父类，都是抽象类
FileInputStream是从硬盘上的文件读取数据,FileOutputStream是将数据写入到硬盘上的文件
声明一个byte类型的数组的方式：byte [] 数组名 = new byte[数组长度]；
数组的长度可以这样表示：数组名.length
操作I/O的时候会产生编译器异常(CheckException)，编译器异常要求我们对其进行try...catch处理
一个英文字母代表一个字节
读取数据的流程：1.导入类（import java.io.*;） 2.声明输入流的引用 3.生成代表输入流的对象（参数为路径，此后要用try...catch处理） 4.生成一个字节数组 5.调用输入流对象的read方法
提示：调用一个String对象的trim方法，将去掉这个字符串的首尾空格和空字符
可以生成一个String类型的对象来输出读取到的数据（调用构造函数时的参数为存放数据的数组）

当read方法没有读到数据时，read方法的返回值为-1
可以使用循环来对大文件进行读写操作9（使用死循环，在死循环当中进行判断，如果read方法返回-1则使用break跳出这个循环,会自动接着上次读取的位置进行读取）
用完I/O流对象后需要对其关上（在finally里面关上）
关闭I/O流的方式为：对象名.close();
关闭I/O流时也可能会产生异常，所以关闭I/O流时也要用try...catch处理
字符流的父类：Reader Writer 都是抽象类（相当于InputStream和OutputStream的位置）
常用的Reader的子类为FileReader(核心方法为read),常用的Writer的子类为FileWriter

装饰者（Decorator）模式
BufferedReader全称：字符输入处理流
主要使用BufferedReader的方法(可以一次性读入一行的数据，然后作为字符串返回)：public String readLine()
生成BufferedReader对象的方法：BufferedReader in = new BufferedReader(new FileReader("foo.in"));
(构造函数的参数为FileReader的对象(当然也可以为其它Reader对象)，“foo.in”代表文件路径)
catch最起码要将异常打印出来
readLine可以判断读到的数据是否为null来判断是否读到数据的尾部
凡是需要使用处理流都要先有节点流
直接对数据源进行操作的是节点流（被装饰者），这些数据源叫做流的节点；使用节点流来间接操作的称为处理流（装饰者）

生成内部类对象要先生成外部类的对象，而内部类的名字为：外部类.内部类
内部类就是在一个类里面再定义一个类（class）
内部类可以使用外部类的成员变量和成员函数，但不是继承
如果想在内部类中使用外部类的this的话，方式是：外部类名.this
匿名内部类就是一个类中（一般情况下是在函数的参数中），new一个接口，后面跟上这个接口的实现类（不用class，直接大括号括起来，可以替代独立实现类）

Dos操作系统是单进程操作系统，同一时间只能操作一件事情
线程也是一个对象
多进程：在操作系统中能（同时）运行多个任务（程序）
多线程：在同一应用程序中有多个顺序流（同时）执行
原则上讲：一个软件只有一个进程，而一个进程又分为很多很多线程
多线程中的线程之间是来回切换执行的（独占CPU，由于CPU的速度快，所以我们没有察觉，仿佛是在同时执行）
创建线程的方法。方式一：定义一个线程类，它继承类Thread并重写其中的方法run()。方法run()称为线程体，在run方法里面可以写上这个线程需要执行的代码。
启动线程需要生成线程的对象然后使用对象的start()方法而不是run()方法
线程之间的运行顺序我们无法干预
在编译调用线程类的类的时候，线程类也会被编译
主函数也占一个线程，还有内存垃圾回收进程

第二种创建线程的方式：创建实现Runnable这个接口的实现类（这个接口也是有一个run()方法，与第一种方法中的run()类似）。
此方式启动线程的方法：首先生成一个Runnable接口实现类的对象，然后生成一个Thread对象，并将Runnable接口的实现类的对象作为参数传递给该Thread对象，最后使用Thread对象的start()方法即可。
实际开发当中应比较倾向于下面第二种创建线程的方式（即非继承，而是实现接口。原因是由于Java当中只支持单继承）
在编译调用线程类的类的时候，线程类也会被编译（和上一种方式一样）
第二种方式将线程体(Runnable的实现类)和线程（Thread）分开了。
在一个类中需要使用令一个类当中的静态方法不需要生成对象，可以直接使用“类名.方法名”来调用。（成员变量也是如此）
Thread方法为静态方法
线程的简单控制方法。中断线程：Thread.sleep(时间) Thread.yield()
休眠是线程处于阻塞状态，醒后为就绪状态
设置线程的优先级：getPriority() setPriority()
进程的优先级也越高的线程执行的概率就越大（注意是概率）

同步代码块的使用方法：sysnchronized(this){同步代码块}
同步代码块的作用是当一个线程获得同步代码块的执行权时（这个线程对象称为同步锁），这段代码不能由其它线程参与运行，当这个线程运行完同步代码块后（这段代码不一定一次运行完毕），这个执行权被释放，代码的执行权重新分配（无法控制）

一旦一个线程获得了以一个对象的同步锁，那么这个对象下面的所有其它的同步的代码都不能被其它线程执行，都需要等待同步锁被释放之后才能够执行(注意是对象被锁住)。但是同步锁不会影响其它非同步的代码的运行。
同步方法的使用方式：在方法的返回值前面加上synchronized
同步方法锁住的也是this
synchronized关键字锁住的是一个对象，而不是代码块

数组和对象都属于引用数据类型
数组的长度可以这样表示：数组名.length
int的默认值为0；char的默认值为null;boolean的默认值为false
二维数组的长度为外层元素的个数，可以表示为：数组名.length
二维数组的某个内层数组的长度可以表示为：数组名[i].length

类集框架是一组类和接口；位于java.util包当中；主要用于存储和管理对象；主要分为三大类：集合、列表和映射
集合（set）。集合中的对象不按特定的方式排序，并且没有重复对象(就算是有重复对象，在使用size方法时都会被忽略)
列表（List）。集合中对象按照索引位置排序，可以有重复的对象
映射（Map）。集合中的每一个元素包含一个键对象和一个值对象，键不可以重复，值可以重复
生成一个ArrayList的对象的方式：ArrayList&lt;类型&gt; 对象名 = new ArrayList&lt;类型&gt;()
向ArrayList中存放数据的方法为：对象名.add(数据)
取出ArrayList对象中的数据方式：对象名.get(索引号)
ArrayList的长度可以这样表示：对象名.size()
可以在ArrayList的对象中删除数据（删除数据后数据的位置会被补上），方法是：对象名.remove(索引号)

set和List都是Collection接口的子接口
集合需要remove一个元素的话直接remove这个元素（而不是索引号）,例如：set.remove("a");
关系：Iterator 调用Set对象的Iterator方法，会生成一个迭代器对象，该对象用于遍历整个Set。如：Iterator it = set.iterator();
迭代器对象的hasNest()方法用于判断后面还有没有元素，若有则会返回true(返回值为boolean型)
迭代器对象的next()方法用于取出后面的元素
iterator方法为Collection的方法，List也是Collection的子类,所以List也可以使用迭代器取出元素

HashMap对象可以存储键值对
生成HashMap对象的方式：HashMap&lt;键类型，值类型&gt; 对象名 = new Hash&lt;键类型，值类型&gt;();
向上转型：Map&lt;键类型，值类型&gt; 对象名 = HashMap的对象名
存入数据：对象名.put(键，值);
取出数据:对象名.get(键);

使用equals方法比较两个对象，默认是比较两个对象的地址，我们可以复写equals方法来达到比较两个引用数据类型的“内容”是否相等（一般情况下比较两个对象的成员变量值是否相等及和比较两个对象的类型是否相同（可以使用instanceof操作符进行比较））
使用instanceof比较两个对象时，不能使用this，需要明确指明哪个对象
所有的类都继承了Object的equals方法（函数）
未复写equals方法情况下比较比较两个对象和使用双等号比较两个对象没有任何区别
使用双等号来比较两个对象时，只是判断双等号两边引用指向堆内存中的地址是否是同一个地址
使用equals的目的一般是比较两个对象中的内容（值）是否相等
equals中向下转型的原因：Object类型（是由生成的本类的对象向上转型而来的话，是能够转型成功的）向下转型为本类型
String类型的equals方法是已经复写好的，可以用于比较两个String类型的内容是否相等
比较基本数据类型的成员变量时使用双等号，比较引用数据类型的成员变量时，一般使用equals来比较

hashCode和equals是相关联的，用equals比较是相等的话，用hashCode比较也应该是相等的
直接打印对象就会调用对象的toString()方法

Workspace工作区：一个目录，这个目录放置了所有开发的程序以及程序使用的资源
Project项目：为一个需求而服务的代码和文件
在workspace可以存放很多Project
在Eclipse中的代码一定要归属于某个项目，不能单独存在

&lt;----------笔记结束
***
附上Mars老师的Java4Android视频（全集）：[百度网盘下载](http://pan.baidu.com/s/1sjLS5u1)


感谢无私奉献的Mars老师

Mars老师的网站：[http://www.marschen.com](http://www.marschen.com)